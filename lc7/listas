/*
 [Car | Cdr]
 primero(X, Car)
 Car es la cabecera de la lista x
*/

/*
Para evitar los singleton usamos func anonimas => primero([Car|_],Car). o segundo([_,Car2|_],Car2).
*/

primero([Car|Cdr],Car).

segundo([Car1,Car2|Cdr],Car2).

/*
Para coger el ultimo elemento habria que usar recursividad
*/

ultimo([Car],Car).
ultimo([Car|Cdr],X):-ultimo(Cdr,X).

/*
Penultimo igual a segundo, pero tengo q forzar q tenga 2 elementos al final
*/

penultimo([Car1,Car2],Car1).
penultimo([Car|Cdr],X):-penultimo(Cdr,X).

/*
Izq,der [2,5,7]
izda_der(2,5,[2,5,7]). true
izq_der(1,2,X) => me genera listas con 1 y 2 seguidas
*/

izq_der(Car1,Car2,[Car1,Car2|Cdr]).
izq_der(N1,N2,[Car|Cdr]):-izq_der(N1,N2,Cdr).

/*
Contigua, igual q el anterior pero habria q hacerlo en los 2 sentidos.
[2,3,4,5,6,7], si le meto 3,4 o 4,3 me tendria q dar true en ambos casos.
Se podria hacer sin llamar a izq_der.
*/

contigua(Car1,Car2,Cdr):-izq_der(Car1,Car2,Cdr).
contigua(Car1,Car2,Cdr):-izq_der(Car2,Car1,Cdr).

/*
Intercalar los elementos de 2 listas (en esta soltaria varias listas si tienen el mismo tam)
*/
int([],L,L).
int(L,[],L).
int([Car1|Cdr1],[Car2|Cdr2],[Car1,Car2|L]):-int(Cdr1,Cdr2,L).

/*
Intercalar los elementos de 2 listas evitando solaparse
*/
int([],L,L).
int(L,[],L):-L\=[].
int([Car1|Cdr1],[Car2|Cdr2],[Car1,Car2|L]):-int(Cdr1,Cdr2,L).

/*
select(elem,[Car|Cdr]) habria q cargarse la primera vez que aparece ese elemento
*/

select(Car,[Car|Cdr],Cdr).
