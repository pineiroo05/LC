/*
 [Car | Cdr]
 primero(X, Car)
 Car es la cabecera de la lista x
*/

/*
Para evitar los singleton usamos func anonimas => primero([Car|_],Car). o segundo([_,Car2|_],Car2).
*/

primero([Car|Cdr],Car).

segundo([Car1,Car2|Cdr],Car2).

/*
Para coger el ultimo elemento habria que usar recursividad
*/

ultimo([Car],Car).
ultimo([Car|Cdr],X):-ultimo(Cdr,X).

/*
Penultimo igual a segundo, pero tengo q forzar q tenga 2 elementos al final
*/

penultimo([Car1,Car2],Car1).
penultimo([Car|Cdr],X):-penultimo(Cdr,X).

/*
Izq,der [2,5,7]
izda_der(2,5,[2,5,7]). true
izq_der(1,2,X) => me genera listas con 1 y 2 seguidas
*/

izq_der(Car1,Car2,[Car1,Car2|Cdr]).
izq_der(N1,N2,[Car|Cdr]):-izq_der(N1,N2,Cdr).

/*
Contigua, igual q el anterior pero habria q hacerlo en los 2 sentidos.
[2,3,4,5,6,7], si le meto 3,4 o 4,3 me tendria q dar true en ambos casos.
Se podria hacer sin llamar a izq_der.
*/

contigua(Car1,Car2,Cdr):-izq_der(Car1,Car2,Cdr).
contigua(Car1,Car2,Cdr):-izq_der(Car2,Car1,Cdr).

/*
Intercalar los elementos de 2 listas (en esta soltaria varias listas si tienen el mismo tam)
*/
int([],L,L).
int(L,[],L).
int([Car1|Cdr1],[Car2|Cdr2],[Car1,Car2|L]):-int(Cdr1,Cdr2,L).

/*
Intercalar los elementos de 2 listas evitando solaparse
*/
int([],L,L).
int(L,[],L):-L\=[].
int([Car1|Cdr1],[Car2|Cdr2],[Car1,Car2|L]):-int(Cdr1,Cdr2,L).

/*
select(elem,[Car|Cdr]) habria q cargarse la primera vez que aparece ese elemento
*/

select(E,[E|Cdr],Cdr).
select(E,[Car|Cdr],[Car|R]):-select(E,Cdr,R).

/*
member -> me dice si esta o no en una lista. Ya lo hay en prolog
*/

miembro(E,[E|Cdr]).
miembro(E,[Car|Cdr]):-miembro(E,Cdr).

/*
append -> para unir listas. Tmb en prolog
[Car1|Cdr1],L,[Car1|R] -> pongo L pq me da igual lo que haya, yo le voy a pegar lo q tenga en Car1
*/
concatenar([],[Car|Cdr],[Car|Cdr]).
concatenar([Car1|Cdr1],L,[Car1|R]):-concatenar(Cdr1,L,R).

/*
invertir -> true si la lista1 es la inversa de lista2
habria q ir quitando de la lista1 y luego metiendolo por el final de nuevo
*/
inv1([],[]).
inv1([Car|Cdr],R):-inv1(Cdr,R2),concatenar(R2,[Car],R).

/*
aplanar->tengo listas, me las tengo q cargar y ponerlas juntas.
atomic comprueba q sea realmente un elemento unico, != a [] pq la [] tmb la considera atomo
*/
aplanar([],[]).
aplanar(atomo,[atomo]):-atomic(atomo),atomo\==[].
aplanar([Car|Cdr],R):-aplanar(Car,Car_apl),aplanar(Cdr,Cdr_apl),concat(Car_apl,Cdr_apl,R).

/*
subconjunto->mejor con select, pero member vale tmb 
*/
subconjunto([],_).
subconjunto([Car|Cdr],L):-select(Car,L,L_SIN_CAR),subconjunto(Cdr,L_SIN_CAR).

/*
linea si tengo [E[1,2,3]] me devolveria tuplas E1,E2,E3
*/
linea(E,[],[]).
linea(E,[Car|Cdr],[[E,Car]|R]):-linea(E,Cdr,R).

/*
Cartesiano
*/
cartesiano([],C2,[]).
cartesiano([Car|Cdr],L2,R):-linea(Car,L2,Linea1),cartesiano(Cdr,L2,R2),concat(Linea1,R2,R).